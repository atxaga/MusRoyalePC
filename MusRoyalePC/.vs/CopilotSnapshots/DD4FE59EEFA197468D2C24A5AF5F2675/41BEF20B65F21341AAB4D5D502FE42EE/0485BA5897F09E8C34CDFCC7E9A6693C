using MusRoyalePC.Models;
using System;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;

using System;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics; // Necesario para Debug.WriteLine
using System.Collections.Generic;
using System.Linq;

namespace MusRoyalePC.Services
{
    public class MusClientService : IDisposable
    {
        private TcpClient? _client;
        private StreamReader? _reader;
        private StreamWriter? _writer;
        private CancellationTokenSource? _listenCts;
        private Task? _listenTask;

        public event Action<string[]>? OnCartasRecibidas;
        public event Action<int, int> OnPuntosRecibidos;
        public event Action? OnMiTurno;
        public event Action<string>? OnComandoRecibido;
        public event Action<Exception>? OnError;
        public event Action? OnDisconnected;

        // NUEVO: evento para que la UI coloque a cada uno en su sitio (arriba/izq/dcha)
        public event Action<AsientosPartida>? OnAsientosCalculados;

        // Datos PROPIOS (rellenados antes de conectar o al recibir INFO)
        public string MiIdFirestore { get; set; }  // <-- IMPORTANTE: Asignar esto en el Login
        public int MiIdTaldea { get; private set; }
        public int MiNumeroJugador { get; private set; }

        // Datos del COMPAÑERO
        public string IdCompanero { get; private set; }
        public int NumeroCompanero { get; private set; }

        // NUEVO: cache de jugadores de la partida
        private List<InfoJugadorPartida> _jugadores = new();

        public bool IsConnected => _client?.Connected == true;

        public async Task Conectar(string ip, int puerto, int timeoutMs = 8000, CancellationToken cancellationToken = default)
        {
            // 1. Limpieza agresiva antes de conectar
            Desconectar();

            try
            {
                _client = new TcpClient();

                // CONFIGURACIÓN CLAVE PARA EVITAR TIMEOUTS Y LAG
                _client.NoDelay = true; // Envío inmediato de paquetes (sin Nagle)
                _client.LingerState = new LingerOption(true, 0); // Hard Reset al cerrar (evita socket fantasma)
                _client.ReceiveTimeout = 0; // Infinito (evita cortes por inactividad de lectura)
                _client.SendTimeout = 10000;

                using var timeoutCts = new CancellationTokenSource(timeoutMs);
                using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(timeoutCts.Token, cancellationToken);

                var connectTask = _client.ConnectAsync(ip, puerto);
                var completed = await Task.WhenAny(connectTask, Task.Delay(Timeout.Infinite, linkedCts.Token));

                if (completed != connectTask)
                {
                    // Si entra aquí, es que el servidor no responde (probablemente por conexión fantasma previa)
                    throw new TimeoutException("El servidor no respondió a tiempo.");
                }

                await connectTask;

                var stream = _client.GetStream();
                _reader = new StreamReader(stream);
                _writer = new StreamWriter(stream) { AutoFlush = true };
            }
            catch (Exception ex)
            {
                Desconectar();
                OnError?.Invoke(ex);
                throw;
            }
        }

        private void ProcesarInfoInicial(string data)
        {
            // Formato real observado:
            // "1OJ2OF6PVJoFusSdlRyzj0,2KemlrTOxaiRnw3ubdjMI1,1eKyEZWQkn9v7Qbkvbbex2,2kHjrbxVjxZQzRHRvvqf73"
            //  ^talde (1 char) + firebaseId (n chars) + id/seat del server (1-2 dígitos al final)
            // IMPORTANTE: el seat del server puede ser 0..3 o 00..03 o incluso 10+ en otros modos.

            string[] tokens = data.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

            var jugadores = new List<InfoJugadorPartida>(4);

            foreach (string raw in tokens)
            {
                if (raw.Length < 3) continue;

                // 1) talde (primer char)
                if (!int.TryParse(raw.AsSpan(0, 1), out int talde))
                    continue;

                // 2) seat: coger dígitos del final (1..2)
                int digits = 0;
                int endIndex = raw.Length - 1;
                while (endIndex >= 1 && digits < 2 && char.IsDigit(raw[endIndex]))
                {
                    digits++;
                    endIndex--;
                }

                if (digits == 0)
                    continue;

                string seatStr = raw.Substring(raw.Length - digits, digits);
                if (!int.TryParse(seatStr, out int seat))
                    continue;

                // 3) firebaseId: entre talde y seat
                int idStart = 1;
                int idLen = raw.Length - 1 - digits;
                if (idLen <= 0) continue;

                string firebaseId = raw.Substring(idStart, idLen);
                if (string.IsNullOrWhiteSpace(firebaseId))
                    continue;

                jugadores.Add(new InfoJugadorPartida
                {
                    Talde = talde,
                    Seat = seat,
                    FirestoreId = firebaseId
                });
            }

            if (jugadores.Count != 4)
            {
                Debug.WriteLine($"[CLIENTE] INFO inválida. Esperaba 4 jugadores y recibí {jugadores.Count}. Data={data}");
                return;
            }

            _jugadores = jugadores;

            // 1) Encontrarme a mí
            var yo = _jugadores.FirstOrDefault(j => j.FirestoreId == MiIdFirestore);
            if (yo == null)
            {
                Debug.WriteLine($"[CLIENTE] No me encuentro en INFO. MiIdFirestore={MiIdFirestore}. Data={data}");
                return;
            }

            MiIdTaldea = yo.Talde;
            MiNumeroJugador = yo.Seat;

            // 2) Encontrar compañero (mismo equipo, distinto id)
            var compa = _jugadores.FirstOrDefault(j => j.Talde == MiIdTaldea && j.FirestoreId != MiIdFirestore);
            if (compa != null)
            {
                IdCompanero = compa.FirestoreId;
                NumeroCompanero = compa.Seat;
            }

            // 3) Calcular asientos relativos.
            // Si el server usa 0..3 como asientos, esto funciona tal cual.
            // Si en algún modo usa otros números, habría que mapear a 0..3; por ahora validamos.
            if (!_jugadores.All(j => j.Seat is >= 0 and <= 3))
            {
                Debug.WriteLine($"[CLIENTE] Seat fuera de rango 0..3 en INFO. Data={data}");
                return;
            }

            int seatFront = (MiNumeroJugador + 2) % 4;
            int seatRight = (MiNumeroJugador + 1) % 4;
            int seatLeft = (MiNumeroJugador + 3) % 4;

            var front = _jugadores.First(j => j.Seat == seatFront);
            var right = _jugadores.First(j => j.Seat == seatRight);
            var left = _jugadores.First(j => j.Seat == seatLeft);

            var asientos = new AsientosPartida
            {
                Yo = yo,
                Front = front,
                Left = left,
                Right = right,
                MiTalde = MiIdTaldea
            };

            Debug.WriteLine($"[CLIENTE] Yo seat={MiNumeroJugador} => Front={seatFront}, Right={seatRight}, Left={seatLeft}");
            Debug.WriteLine($"[CLIENTE] Front={front.FirestoreId} (talde {front.Talde}) | Left={left.FirestoreId} | Right={right.FirestoreId}");

            OnAsientosCalculados?.Invoke(asientos);
        }

        public async Task<string> ConectarYUnirse(string ip, int puerto, string modo, string codigo = "")
        {
            if (_client == null || !_client.Connected)
            {
                await Conectar(ip, puerto);
            }

            // Enviamos el modo UNA SOLA VEZ
            await EnviarLineaAsync(modo);

            switch (modo)
            {
                case "CREAR_PRIVADA":
                    await EnviarLineaAsync(UserSession.Instance.DocumentId);

                    string confirmacion = await LeerLineaAsync(); // "CODIGO"
                    string codigoGenerado = await LeerLineaAsync();

                    IniciarEscucha();
                    return codigoGenerado;

                case "UNIRSE_PRIVADA":
                    string resp = await LeerLineaAsync(); // "PEDIR_CODIGO"
                    if (resp == "PEDIR_CODIGO")
                    {
                        await EnviarLineaAsync(codigo);
                        await EnviarLineaAsync(UserSession.Instance.DocumentId);

                        string finalOk = await LeerLineaAsync(); // "OK"
                        if (finalOk == "OK")
                        {
                            IniciarEscucha();
                            return "OK";
                        }
                    }
                    return "ERROR";

                case "PUBLICA":
                case "BIKOTEAK":
                    Console.WriteLine($"[CLIENTE] Enviando DocumentId para {modo}: {UserSession.Instance.DocumentId}");
                    await EnviarLineaAsync(UserSession.Instance.DocumentId);

                    string okPub = await LeerLineaAsync(); // "OK"
                    if (okPub == "OK")
                    {
                        IniciarEscucha();
                        return "OK";
                    }
                    return "ERROR";

                default:
                    return "ERROR_MODO_NO_SOPORTADO";
            }
        }

        private void IniciarEscucha()
        {
            _listenCts?.Cancel();
            _listenCts = new CancellationTokenSource();
            _listenTask = Task.Run(() => EscucharServidor(_listenCts.Token));
        }

        private async Task EscucharServidor(CancellationToken ct)
        {
            try
            {
                while (!ct.IsCancellationRequested && _client != null && _client.Connected)
                {
                    string? linea = await _reader.ReadLineAsync();

                    if (linea == null)
                    {
                        Debug.WriteLine("Servidor cerró la conexión (FIN).");
                        break;
                    }

                    switch (linea)
                    {
                        case "CARDS":
                            await LeerYEnviarCartas();
                            break;

                        case "TURN":
                            OnMiTurno?.Invoke();
                            break;

                        case "GRANDES":
                        case "PEQUEÑAS":
                        case "PARES":
                        case "JUEGO":
                            OnComandoRecibido?.Invoke(linea);
                            break;

                        case "PUNTUAKJASO":
                            string[] pts = new string[4];
                            for (int i = 0; i < 4; i++) pts[i] = await LeerLineaAsync() ?? "0";
                            OnComandoRecibido?.Invoke($"PUNTOS|{string.Join("|", pts)}");
                            break;

                        case "ALL_MUS":
                            OnComandoRecibido?.Invoke("ALL_MUS");
                            break;

                        default:
                            if (EsCarta(linea))
                            {
                                await LeerCartasSueltas(linea);
                            }
                            else if (linea.StartsWith("INFO:", StringComparison.Ordinal))
                            {
                                ProcesarInfoInicial(linea.Substring(5));
                            }
                            else if (linea.StartsWith("PUNTOS:", StringComparison.Ordinal))
                            {
                                try
                                {
                                    string[] partes = linea.Split(':');

                                    if (partes.Length >= 3)
                                    {
                                        int idTaldea = int.Parse(partes[1]);
                                        int cantidad = int.Parse(partes[2]);
                                        OnPuntosRecibidos?.Invoke(idTaldea, cantidad);
                                    }
                                }
                                catch
                                {
                                    Debug.WriteLine("Error leyendo formato de puntos");
                                }
                            }
                            else
                            {
                                OnComandoRecibido?.Invoke(linea);
                            }
                            break;
                    }
                }
            }
            catch (IOException ioEx)
            {
                Debug.WriteLine($"Error de socket: {ioEx.Message}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error general escucha: {ex.Message}");
            }
            finally
            {
                if (!ct.IsCancellationRequested)
                {
                    OnDisconnected?.Invoke();
                }
                Desconectar();
            }
        }

        private async Task EnviarLineaAsync(string mensaje)
        {
            if (_writer == null) return;
            _writer.WriteLine(mensaje);
        }

        private async Task<string> LeerLineaAsync()
        {
            if (_reader == null) return null;
            return await _reader.ReadLineAsync();
        }

        private async Task LeerCartasSueltas(string primeraCarta)
        {
            string[] cartas = new string[4];
            cartas[0] = primeraCarta;
            for (int i = 1; i < 4; i++)
            {
                cartas[i] = await LeerLineaAsync() ?? "";
            }
            OnCartasRecibidas?.Invoke(cartas);
        }

        private async Task LeerYEnviarCartas()
        {
            string[] cartas = new string[4];
            for (int i = 0; i < 4; i++)
            {
                cartas[i] = await LeerLineaAsync() ?? "";
            }
            OnCartasRecibidas?.Invoke(cartas);
        }

        private bool EsCarta(string linea)
        {
            if (string.IsNullOrEmpty(linea)) return false;
            string[] palos = { "oro", "copa", "espada", "basto" };
            foreach (var palo in palos)
            {
                if (linea.StartsWith(palo, StringComparison.OrdinalIgnoreCase)) return true;
            }
            return false;
        }

        public void EnviarComando(string comando)
        {
            try
            {
                if (_writer != null && _client?.Connected == true)
                {
                    _writer.WriteLine(comando);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Error al enviar: " + ex.Message);
            }
        }

        public void Desconectar()
        {
            try
            {
                _listenCts?.Cancel();

                _writer?.Close();
                _reader?.Close();

                if (_client != null)
                {
                    _client.Close();
                    _client.Dispose();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error al desconectar: {ex.Message}");
            }
            finally
            {
                _writer = null;
                _reader = null;
                _client = null;
                _listenCts = null;
            }
        }

        public void Dispose() => Desconectar();
    }

    public sealed class InfoJugadorPartida
    {
        public required string FirestoreId { get; init; }
        public required int Talde { get; init; }
        public required int Seat { get; init; } // 0..3 en mesa
    }

    public sealed class AsientosPartida
    {
        public required InfoJugadorPartida Yo { get; init; }
        public required InfoJugadorPartida Front { get; init; }
        public required InfoJugadorPartida Left { get; init; }
        public required InfoJugadorPartida Right { get; init; }
        public required int MiTalde { get; init; }

        public bool EsMiEquipo(InfoJugadorPartida j) => j.Talde == MiTalde;
    }
}